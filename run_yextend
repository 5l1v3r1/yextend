#!/usr/bin/env python

"""
    run statement:

    ./run_yextend -r rule_entity -t target_file_entity [-j]

    I label them as 'entity' because they can each be
    either a directory or a file
"""
import subprocess
import sys
import os
import fnmatch
import time
import getopt
import json
from types import *
from collections import OrderedDict
########################################################
def usage():
    print "\n{}\n".format("Usage:")

    print "{} {} {} {}\n".format("./run_yextend", "-r rule_entity", "-t target_file_entity", "[-j]")

    print "    {}".format("-r RULES_FILE = Yara ruleset file [*required]")
    print "    {}".format("-t TARGET_ENTITY = file or directory [*required]")
    print "    {}".format("-j output in JSON format and nothing more [optional]")

    print "".format("\n\n")


def get_file_list(thedir='', thepattern='*'):
    f_list = []
    if thedir:
        for root, dirnames, filenames in os.walk(thedir):
            for name in fnmatch.filter(filenames, thepattern):
                complete_fname = "{}{}".format(root, name)
                if os.path.isfile(complete_fname):
                    if complete_fname not in f_list:
                        f_list.append(complete_fname)
    return f_list


def my_print(thestr='', thecolor=''):
    if thestr:
        format_str = '\033[1;{}m{}\033[1;m'
        if thecolor == 'gray':
            return format_str.format('30', thestr)
        elif thecolor == 'red':
            return format_str.format('31', thestr)
        elif thecolor == 'green':
            return format_str.format('32', thestr)
        elif thecolor == 'yellow':
            return format_str.format('33', thestr)
        elif thecolor == 'blue':
            return format_str.format('34', thestr)
        elif thecolor == 'magenta':
            return format_str.format('35', thestr)
        elif thecolor == 'cyan':
            return format_str.format('36', thestr)
        elif thecolor == 'white':
            return format_str.format('37', thestr)
        elif thecolor == 'crimson':
            return format_str.format('38', thestr)
        elif thecolor == 'highlighted_red':
            return format_str.format('41', thestr)
        elif thecolor == 'highlighted_red':
            return format_str.format('42', thestr)
        elif thecolor == 'highlighted_brown':
            return format_str.format('43', thestr)
        elif thecolor == 'highlighted_blue':
            return format_str.format('44', thestr)
        elif thecolor == 'highlighted_magenta':
            return format_str.format('45', thestr)
        elif thecolor == 'highlighted_cyan':
            return format_str.format('46', thestr)
        elif thecolor == 'highlighted_gray':
            return format_str.format('47', thestr)
        elif thecolor == 'highlighted_crimson':
            return format_str.format('48', thestr)


def which(program=""):
    def is_exe(fpath):
        return os.path.exists(fpath) and os.access(fpath, os.X_OK)

    def ext_candidates(fpath):
        yield fpath
        for ext in os.environ.get("PATHEXT", "").split(os.pathsep):
            yield fpath + ext

    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        tarr = os.environ["PATH"].split(os.pathsep)
        tarr.append("/sbin")
        tarr.append("./")
        for path in tarr:
            exe_file = os.path.join(path, program)
            for candidate in ext_candidates(exe_file):
                if is_exe(candidate):
                    return candidate
    return None


def print_yextend_output(out=''):
    if out:
        for the_out in out.split('\n'):
            if the_out.startswith('='):
                print my_print(thestr=the_out, thecolor='white')
            elif the_out.startswith("Yara "):
                # print the_out
                t_o = the_out.split(': ')
                print "{}: ".format(my_print(thestr=t_o[0], thecolor='white'))
                for rule_data in t_o[1].split(', '):
                    if ':[' in rule_data:
                        rule_id, rule_meta = rule_data.split(':[')
                        rule_meta = rule_meta[:-1]
                        print "\tRule ID: {}".format(my_print(thestr=rule_id, thecolor='red'))
                        print "\tRule META:"
                        for rmeta in rule_meta.split(','):
                            rmeta = rmeta.replace('=', ' = ')
                            if rmeta.startswith('detected'):
                                rm_label, rm_dat = rmeta.split(' = ')
                                print "\t\t{}".format(my_print(thestr=rm_label + ':', thecolor='blue'))
                                rm_dat_spl = rm_dat.split('-')

                                for rmdspl in rm_dat_spl:
                                    try:
                                        rmdspl_offset, rmdspl_label = rmdspl.strip().split(':')
                                    except ValueError:
                                        pass
                                    rmdspl_out = "{} at {}".format(my_print(thestr=rmdspl_label, thecolor='red'), my_print(rmdspl_offset, thecolor='red'))
                                    print "\t\t\t{}".format(my_print(thestr=rmdspl_out, thecolor='blue'))
                            else:
                                print "\t\t{}".format(my_print(thestr=rmeta, thecolor='blue'))
                    else:
                        if rule_data == "No hit from Yara ruleset":
                            print "\t{}".format(my_print(thestr=rule_data, thecolor='red'))
                        else:
                            print "\tRule ID: {}".format(my_print(thestr=rule_data, thecolor='red'))
                    print
            elif the_out == '\n':
                print the_out
            else:
                try:
                    t_o = the_out.split(': ')
                    print "{}: {}".format(my_print(thestr=t_o[0], thecolor='white'), my_print(thestr=t_o[1], thecolor='green'))
                except:
                    def_out = my_print(thestr=the_out, thecolor='white')
                    if def_out:
                        print my_print(thestr=the_out, thecolor='white')
                    else:
                        print the_out


def print_yextend_json_output(out=''):

    if out:

        try:
            string_to_json = json.loads(out)

            for rule_file in string_to_json:

                print '\n{}'.format(my_print(thestr='===============================ALPHA===================================', thecolor='white'))
                print '{} : {}'.format(my_print(thestr="File Name", thecolor='white'), my_print(thestr=rule_file['file_name'], thecolor='green'))
                print '{} : {}'.format(my_print(thestr="File Size", thecolor='white'), my_print(thestr=rule_file['file_size'], thecolor='green'))
                print '{} : {}'.format(my_print(thestr="File Signature (MD5)", thecolor='white'), my_print(thestr=rule_file['file_signature_MD5'], thecolor='green'))

                if 'yara_ruleset_file_name' in rule_file.keys():
                    print '{} : {}'.format(my_print(thestr="Yara Ruleset File Name", thecolor='white'), my_print(thestr=rule_file['yara_ruleset_file_name'], thecolor='green'))

                print '\n{}\n'.format(my_print(thestr='=======================================================================', thecolor='white'))
                print my_print(thestr='Yara Result(s):', thecolor='white')

                if ('scan_results' in rule_file) and (rule_file['scan_results'] is not None):

                    for result in rule_file['scan_results']:
                        res_keys = result.keys()
                        if result['yara_matches_found']:

                            print '\tRule ID: {}'.format(my_print(thestr=result['yara_rule_id'], thecolor='red'))
                            print '\tRule META:'

                            for key, value in result.iteritems():
                                if key == 'detected offsets':
                                    constructed_out = key + ':'
                                    print '\t\t{}'.format(my_print(thestr=constructed_out, thecolor='blue'))
                                    for detect in value:
                                        if (":") in detect:
                                            offset,label = detect.split(':')
                                        else:
                                            offset = detect
                                            label = "UNK"
                                        constructed_out = '{} at {}'.format(my_print(thestr=label, thecolor='red'), my_print(offset, thecolor='red'))
                                        print '\t\t\t{}'.format(my_print(thestr=constructed_out, thecolor='blue'))
                                else:
                                    if key not in ['scan_type', 'file_name', 'file_signature_MD5', 'yara_rule_id', 'yara_matches_found']:
                                        constructed_pair = key + ' = ' + str(value)
                                        print '\t\t{}'.format(my_print(thestr=constructed_pair, thecolor='blue'))

                            if len(result) <= 2:
                                print '\t\t{}\n'.format('None')

                            if 'scan_type' in res_keys:
                                print '\n{} : {}'.format(my_print(thestr="Scan Type", thecolor='white'), my_print(thestr=result['scan_type'], thecolor='green'))

                            if 'file_name' in res_keys:
                                print '{} : {}'.format(my_print(thestr="File Name", thecolor='white'), my_print(thestr=result['file_name'], thecolor='green'))

                            if 'child_file_name' in res_keys:
                                print '{} : {}'.format(my_print(thestr="Child File Name", thecolor='white'), my_print(thestr=result['child_file_name'], thecolor='green'))

                            if 'parent_file_name' in res_keys:
                                print '{} : {}'.format(my_print(thestr="Parent File Name", thecolor='white'), my_print(thestr=result['parent_file_name'], thecolor='green'))

                            if 'file_signature_MD5' in res_keys:
                                print '{} : {}\n'.format(my_print(thestr="File Signature (MD5)", thecolor='white'), my_print(thestr=result['file_signature_MD5'], thecolor='green'))

                        else:

                            print '\tRule ID: {}\n'.format('None')

                            if 'scan_type' in res_keys:
                                print '{} : {}'.format(my_print(thestr="Scan Type", thecolor='white'), my_print(thestr=result['scan_type'], thecolor='green'))

                            if 'non_archive_file_name' in res_keys:
                                print '{} : {}'.format(my_print(thestr="Non-Archive File Name", thecolor='white'), my_print(thestr=result['non_archive_file_name'], thecolor='green'))

                            if 'file_name' in res_keys:
                                print '{} : {}'.format(my_print(thestr="File Name", thecolor='white'), my_print(thestr=result['file_name'], thecolor='green'))

                            if 'parent_file_name' in res_keys:
                                print '{} : {}'.format(my_print(thestr="Parent File Name", thecolor='white'), my_print(thestr=result['parent_file_name'], thecolor='green'))

                            if 'child_file_name' in res_keys:
                                print '{} : {}'.format(my_print(thestr="Child File Name", thecolor='white'), my_print(thestr=result['child_file_name'], thecolor='green'))

                            if 'file_signature_MD5' in res_keys:
                                print '{} : {}\n'.format(my_print(thestr="File Signature (MD5)", thecolor='white'), my_print(thestr=result['file_signature_MD5'], thecolor='green'))

                print '{}\n'.format(my_print(thestr='===============================OMEGA===================================', thecolor='white'))

        except:

            # when file can't be read
            t_o = out.split(': ')
            print '{}: {}'.format(my_print(thestr=t_o[0], thecolor='white'), my_print(thestr=t_o[1].strip("null"), thecolor='green'))

########################################################

RULES_ENTITY = ''
FILE_ENTITY = ''
RULES_ENTITY_DIR = False
YEXTEND = which(program="yextend")
LD_LIBRARY_PATH = "{}".format("LD_LIBRARY_PATH")
USRLOCLIB = "{}".format("\/usr\/local\/lib")
JSON_OUT = False
ADVANCED = False
try:
    options, rem = getopt.getopt(sys.argv[1:], 'r:t:ja', ['ruleset=','target='])
except getopt.GetoptError as err:
    print str(err)
    usage()
    sys.exit()

for opt, arg in options:
    if opt in ('-r', '--ruleset'):
        RULES_ENTITY = "{}".format(arg)
    elif opt in ('-t', '--target'):
        FILE_ENTITY = "{}".format(arg)
    elif opt in ('-j'):
        JSON_OUT = True
    elif opt in ('-a'):
        ADVANCED = True
    else:
        assert False, "unhandled option"

if os.path.isdir(RULES_ENTITY):
    RULES_ENTITY_DIR = True

if not RULES_ENTITY or not FILE_ENTITY:
    usage()
    sys.exit()

'''
	we will force the JSON option to yextend
	as the default run mode going forward

	function 'print_yextend_json_output' presents
	the results of a run to stdout the same way
	we always have except that under the hood it
	is transforming the JSON output from yextend
	instead of transforming the legacy output
	format (i.e. non-JSON)
'''
JSON_OUT_FORCE = "-j"
if JSON_OUT:
    JSON_OUT = "-j"
else:
    JSON_OUT = ""

def advanced_print(out):

    out = json.loads(out)

    final = []

    def format_dict(child):
        if "child_file_name" in child:
            child["file_name"] = child.pop("child_file_name")
        elif "non_archive_file_name" in child:
            child["file_name"] = child.pop("non_archive_file_name")

        if "yara_rule_id" in child:
            rule_id = child["yara_rule_id"]
            try:
                yara_results = {rule_id:{}}
                if "description" in child:
                    yara_results[rule_id]["description"] = child["description"]
                else:
                    yara_results[rule_id]["description"] = ""
                if "detected offsets" in child:
                    yara_results[rule_id]["offsets"] = child["detected offsets"]
                    del child["detected offsets"]

                del child["yara_rule_id"]
                child["yara_results"] = yara_results

            except Exception,e:
                print e

        if "scan_results" in child:
            del child["scan_results"]

        return child

    def add_results(all_files,new_dict,name,file_sig):

        if "yara_results" in new_dict:
            all_files[(name,file_sig)]["yara_results"].update(new_dict["yara_results"])


    for file_dict in out:
        #dictionary of all files name:metadata
        all_files = {}
        #map parents to children just using file name and we will get metadata from all_files when needed
        parent_child = {}

        name=file_dict["file_name"]
        file_sig=file_dict["file_signature_MD5"]
        new_dict = format_dict(dict(file_dict))

        try:
            new_dict["yara_results"]
        except:
            new_dict["yara_results"] = {}

        try:
            all_files[(name,file_sig)]
            if new_dict["yara_results"]:
                add_results(all_files,format_dict(new_dict),name,file_sig)           

        except Exception, e:
            all_files[(name,file_sig)] = new_dict

        for child in file_dict["scan_results"]:

            child_dict = format_dict(child)
            name = child_dict["file_name"]
            file_sig = child_dict["file_signature_MD5"]

            if (name,file_sig) in all_files:
                add_results(all_files,child_dict,name,file_sig)
            else:
                all_files[(name,file_sig)] = child_dict

            if "parent_file_name" in child:
                try:
                    if (name,file_sig) not in parent_child[child["parent_file_name"]]:
                        parent_child[child["parent_file_name"]].append((name,file_sig))
                except Exception, e:
                    parent_child[child["parent_file_name"]] = [(name,file_sig)]

            #when it's a non-archived file map it as its own child
            else:
                try:
                    if (name,file_sig) not in parent_child[child["file_name"]]:
                        parent_child[child["file_name"]].append((name,file_sig))
                except:
                    parent_child[child["file_name"]] = [(name,file_sig)]

        keyorder = ["file_name","file_signature_MD5","file_size","yara_matches_found", "hit_count", "yara_ruleset_file_name", "scan_type", "yara_results"]

        for f in all_files:
            if "parent_file_name" in all_files[f]:
                del all_files[f]["parent_file_name"]
            try:
                if f[0] in parent_child and parent_child[f[0]]:
                    obj = OrderedDict()
                    for key in keyorder:
                        if key in all_files[f]:
                            obj[key] = all_files[f][key]

                    if len(parent_child[f[0]]) == 1 and parent_child[f[0]] == [f]:
                        pass
                    else:                        
                        obj["children"] = []
                        for child in parent_child[f[0]]:
                            new_child = OrderedDict()
                            for key in keyorder:
                                if key in all_files[child]:
                                    new_child[key] = all_files[child][key]
                            obj["children"].append(new_child)

                    final.append(obj)

            except Exception, e:
                print e

    return final

''' ruleset = file '''
if not RULES_ENTITY_DIR:
    proc = subprocess.Popen([YEXTEND, "-r", RULES_ENTITY, "-t", FILE_ENTITY, JSON_OUT_FORCE],
                            env={LD_LIBRARY_PATH:USRLOCLIB},
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE,
                            )
    out, err = proc.communicate()
    if out:
        if JSON_OUT:
            if ADVANCED:
                print json.dumps(advanced_print(out), indent=4)
            else:
                #print_yextend_json_output(out=out)
                print out
        else:
            #print_yextend_output(out=out)
            print_yextend_json_output(out=out)
    '''
    if err:
        print "ERR: %s" % err
    '''

''' ruleset = dir '''
if RULES_ENTITY_DIR:
    for lpol in get_file_list(thedir=RULES_ENTITY):
        proc = subprocess.Popen([YEXTEND, "-r", lpol, "-t", FILE_ENTITY, JSON_OUT_FORCE],
                                env={LD_LIBRARY_PATH:USRLOCLIB},
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE,
                                )
        out, err = proc.communicate()
        if out:
            if JSON_OUT:
                if ADVANCED:
                    print json.dumps(advanced_print(out), indent=4)
                else:
                    #print_yextend_json_output(out=out)
                    print out
            else:
                #print_yextend_output(out=out)
                print_yextend_json_output(out=out)
        '''
        if err:
            print "ERR: %s" % err
        '''
